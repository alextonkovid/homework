# Домашнее задание к занятию "6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

---

`Для остановки запроса пользователя в MongoDB можно произвести следующие действия:`

1. Использовать команду db.currentOp() для получения списка текущих операций в базе данных MongoDB.
2. Найти операцию, связанную с пользователем, который запустил долгую операцию CRUD.
3. Использовать команду db.killOp(<opid>), где <opid> - идентификатор операции, чтобы прервать ее выполнение.

`Для предотвращения долгих (зависающих) запросов в MongoDB можно применять следующие методы:`

1. Использовать индексы. Индексы позволяют MongoDB быстро находить и извлекать документы из базы данных. Необходимо правильно настроить индексы для коллекций, которые часто используются в операциях CRUD.
2. Оптимизировать запросы. Приложение должно запрашивать только те данные, которые ему действительно нужны. Кроме того, можно использовать агрегационные функции MongoDB для агрегирования данных на сервере.
3. Использовать лимиты и тайм-ауты. Необходимо настроить лимиты и тайм-ауты для операций CRUD, чтобы предотвратить долгие операции.
4. Масштабирование. Если база данных слишком большая, ее можно разбить на несколько частей и хранить на разных серверах. Это позволит распределить нагрузку и ускорить операции CRUD.
---

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

---

**Redis не может быстро обрабатывать истекшие ключи и удалять их из базы данных.**
Когда количество реплик увеличивается, также увеличивается количество ключей, которые Redis должен обслуживать. Если Redis не может быстро обрабатывать истекшие ключи, то со временем база данных Redis может заполниться до такой степени, что большая часть памяти будет занята истекшими ключами, а не актуальными данными.

Таким образом, Redis блокирует операции записи, чтобы предотвратить дальнейшее заполнение базы данных.

Для решения этой проблемы можно использовать следующие подходы:

- Увеличить количество ресурсов, выделенных для Redis, такие как память, CPU и хранилище, чтобы Redis мог быстрее обрабатывать истекшие ключи и удалять их из базы данных.
- Настроить Redis на автоматическое удаление старых ключей с помощью опции "eviction policy".
- При необходимости, можно использовать Redis Cluster для распределения данных между несколькими Redis-узлами, чтобы снизить нагрузку на отдельный инстанс Redis.

---

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

---
**Эта ошибка может происходить по нескольким причинам:**
1. Сервер MySQL не может обработать запрос из-за ограничений производительности, таких как недостаточно памяти, проблем с процессором или сетью.

2. Проблемы с сетевым подключением, такие как сбои в сети или перегрузка.

3. Ошибки в самом приложении, например, попытка выполнить слишком много запросов одновременно.

**Для локализации проблемы :**

1. Проверить журналы ошибок MySQL и определить, были ли там какие-либо проблемы во время выполнения запроса.

2. Проверить состояние сети и среду выполнения сервера MySQL, чтобы выяснить, есть ли какие-либо проблемы с производительностью.

3. Проверить приложение на предмет ошибок в коде, которые могут вызывать проблемы при выполнении запросов.

**Чтобы решить эту проблему:**

1. Увеличить параметры конфигурации сервера MySQL, такие как максимальное количество подключений, пул соединений и буферизацию запросов.

2. Оптимизировать свои запросы и структуру базы данных, чтобы уменьшить нагрузку на сервер.

3. Использовать инструменты мониторинга производительности, чтобы отслеживать работу сервера MySQL и выявлять проблемы в режиме реального времени.

4. Разделить базу данных на несколько таблиц и использовать индексы для ускорения выполнения запросов.

5. Установить и настроить соответствующие драйверы для работы с базой данных, чтобы уменьшить время ответа и улучшить производительность.
---
## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

---
PostgreSQL потребляет слишком много оперативной памяти, что приводит к исчерпанию свободного пространства в памяти и вызывает процесс OOM-killer для освобождения памяти. Это может происходить при работе с большими объемами данных или при неправильной настройке параметров конфигурации PostgreSQL.

Для решения этой проблемы:

1. Проверить параметры конфигурации PostgreSQL и проверить, что они оптимизированы для среды. Попробовать уменьшить размер буферов, снизить максимальное количество соединений или увеличить лимиты памяти для PostgreSQL.

2. Использовать инструменты мониторинга производительности, чтобы отслеживать использование памяти PostgreSQL и выявлять утечки памяти.

3. Оптимизировать свои запросы и структуру базы данных, чтобы уменьшить нагрузку на сервер PostgreSQL.

5. Увеличить объем оперативной памяти на сервере.

6. Разделить базу данных на несколько таблиц и использовать индексы для ускорения выполнения запросов.

---
